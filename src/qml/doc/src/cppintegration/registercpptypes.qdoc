/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/
/*!
\page qtqml-cppintegration-registercpptypes.html
\title Defining QML Object Types from C++
\brief Description of how to register C++ types with the QML type system




\section1 Defining New QML Elements

While new QML elements can be \l {Defining New Components}{defined in QML}, they can also be
defined by C++ classes; in fact, many of the core \l {QML Elements} are implemented through
C++ classes. When you create a QML object using one of these elements, you are simply creating an
instance of a QObject-based C++ class and setting its properties.

To create a visual item that fits in with the Qt Quick elements, base your class off \l QQuickItem instead of QObject directly.
You can then implement your own painting and functionality like any other QGraphicsObject. Note that QGraphicsItem::ItemHasNoContents is set by default on QQuickItem because
it does not paint anything; you will need to clear this if your item is supposed to paint anything (as opposed to being solely for input handling or logical grouping).

For example, here is an \c ImageViewer class with an \c image URL property:

\snippet qml/qtbinding/newelements/imageviewer.h 0

Aside from the fact that it inherits QQuickItem, this is an ordinary class that could
exist outside of QML. However, once it is registered with the QML engine using qmlRegisterType():

\snippet qml/qtbinding/newelements/main.cpp register

Then, any QML code loaded by your C++ application or \l{QQmlExtensionPlugin}{plugin} can create and manipulate
\c ImageViewer objects:

\snippet qml/qtbinding/newelements/standalone.qml 0


It is advised that you avoid using QGraphicsItem functionality beyond the properties documented in QQuickItem.
This is because the GraphicsView backend is intended to be an implementation detail for QML, so the QtQuick items can be moved to faster backends as they become available with no change from a QML perspective.
To minimize any porting requirements for custom visual items, try to stick to the documented properties in QQuickItem where possible. Properties QQuickItem inherits but doesn't document are classed as implementation details; they are not officially supported and may disappear between releases.

Note that custom C++ types do not have to inherit from QQuickItem; this is only necessary if it is
a displayable item. If the item is not displayable, it can simply inherit from QObject.

For more information on defining new QML elements, see the \l {Tutorial: Extending QML with C++}
{Writing QML extensions with C++} tutorial and the
\l{Extending QML with C++} reference documentation.




\section1 Subclassing QQmlParserStatus

    Often, to develop high performance elements it is helpful to know more about
    the status of the QML engine. For example, it might be beneficial to delay
    initializing some costly data structures until after all the properties have
    been set.

    The QML engine defines an interface class called QQmlParserStatus,
    which contains a number of virtual methods that are invoked at various
    stages during component instantiation. To receive these notifications, an
    element implementation inherits QQmlParserStatus and notifies the Qt
    meta system using the Q_INTERFACES() macro.

    \code
    class Example : public QObject, public QQmlParserStatus
    {
        Q_OBJECT
        Q_INTERFACES(QQmlParserStatus)
    public:
        virtual void componentComplete()
        {
            qDebug() << "Woohoo!  Now to do my costly initialization";
        }
    };
    \endcode






\target register-c++-type
\section1 Register a Type

The \l{QQmlEngine}{QML engine} can instantiate any Qt C++ construct
such as \l{The Property System}{properties}, functions, and data models into
the QML context allowing the constructs to be accessible from within QML.


    In an application or a \l{QML Plugins}{plugin}, the \c qmlRegisterType
    template will register a class to the QML engine.

\code
template<typename T>
int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)
\endcode

    \l qmlRegisterType() registers the C++ type \a T with the QML system, and
    makes it available to the QML context under the name \c qmlName in library
    \c uri version \c versionMajor.versionMinor. The \c qmlName can be the same
    as the C++ type name.

    Suppose that a \c Person class defined in a C++ is to be exposed into the
    QML context. The class must be a subclass of \l{QObject} and have a default
    constructor. The \l{The Property System}{properties} created with the
    Q_PROPERTY macro are visible in the QML context as well.
    \snippet examples/qml/cppextensions/referenceexamples/adding/person.h 0

    The application registers the class to the runtime with the
    \l{qmlRegisterType()}.

    \snippet examples/qml/cppextensions/referenceexamples/adding/main.cpp 0

    The Person type is then imported with the \c "People 1.0" module and its
    properties are accessible in a QML file.
    \snippet examples/qml/cppextensions/referenceexamples/adding/example.qml 0

    The \l {Extending QML - Adding Types Example}{Adding Types} example
    demonstrates as usage of the \l qmlRegisterType().

    Alternatively, these functions provide a way for other types of C++ types
    to be visible in the QML context.
    \list
    \li \l qmlRegisterModuleApi() is suited for registering either a QJSValue
    or QObject module API (shared instance) into a namespace
    \li \l qmlRegisterUncreatableType() is suited for attached
    properties and enum types.
    \li \l qmlRegisterTypeNotAvailable() is for
    reserving a namespace and suited for generating useful errors.
    \li \l qmlRegisterInterface() - for registering base or abstract classes for
    \l{qml-c++-coercion}{coercion and inheritance}. This is useful for general
    Qt objects or \l{Qt Objects and Interfaces}{pointers} to objects.
    \li \l qmlRegisterExtendedType() - for \l{qml-c++-extension}{extended types}
    \endlist

    \section2 Qt Objects and Interfaces
    QML can bind to complex objects such as pointers to objects or lists. As QML
    is typesafe, the \l{QQmlEngine}{QML engine} ensures that only
    valid types are assigned to these properties.

    The QML engine treats pointers to objects or Qt interfaces the same
    way as regular properties. Thus, the lists or pointers are created as
    properties using the Q_PROPERTY() macro.

    \snippet examples/qml/cppextensions/referenceexamples/properties/birthdayparty.h 1

    The \c host is an \l{qml-expose-properties}{exposed property} that can bind
    to objects or lists of objects. The property type, in this case \c Person,
    must be \l{Creating QML Object Types from C++}{registered} into the runtime.

    QML also supports assigning Qt interfaces. To assign to a property whose
    type is a Qt interface pointer, the interface must also be registered with
    QML. As they cannot be instantiated directly, registering a Qt interface is
    different from registering a new QML type. The following function is used
    instead:

    \code
    template<typename T>
    int qmlRegisterInterface(const char *typeName)
    \endcode

    This function registers the C++ interface \a T with the QML system as \a
    typeName.

    Following registration, QML can \l{qml-c++-coercion}{coerce} objects that
    implement this interface for assignment to appropriately typed properties.

\section1 Type Revisions and Versions

    Type revisions and versions allow new properties or methods to exist in the
    new version while remaining compatible with previous versions.

    Consider these two QML files:
    \code
    // main.qml
    import QtQuick 1.0
    Item {
        id: root
        MyComponent {}
    }
    \endcode

    \code
    // MyComponent.qml
    import MyModule 1.0
    CppItem {
        value: root.x
    }
    \endcode
    where \c CppItem maps to the C++ class \c QCppItem.

    If the author of QCppItem adds a \c root property to QCppItem in a new
    version of the module, \c root.x now resolves to a different value because
    \c root is also the \c id of the top level component. The author could
    specify that the new \c root property is available from a specific minor
    version. This permits new properties and features to be added to existing
    elements without breaking existing programs.

    The REVISION tag is used to mark the \c root property as added in revision 1
    of the class. Methods such as Q_INVOKABLE's, signals and slots can also be
    tagged for a revision using the \c Q_REVISION(x) macro:

    \code
    class CppElement : public BaseObject
    {
        Q_OBJECT
        Q_PROPERTY(int root READ root WRITE setRoot NOTIFY rootChanged REVISION 1)

    signals:
        Q_REVISION(1) void rootChanged();
    };
    \endcode

    To register the new class revision to a particular version the following function is used:

    \code
    template<typename T, int metaObjectRevision>
    int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)
    \endcode

    To register \c CppElement version 1 for \c {MyModule 1.1}:

    \code
    qmlRegisterType<QCppElement,1>("MyModule", 1, 1, "CppElement")
    \endcode

    \c root is only available when MyModule 1.1 is imported.

    For the same reason, new elements introduced in later versions should use
    the minor version argument of qmlRegisterType.

    This feature of the language allows for behavioural changes to be made
    without breaking existing applications. Consequently QML module authors
    should always remember to document what changed between minor versions, and
    QML module users should check that their application still runs correctly
    before deploying an updated import statement.

    You may also register the revision of a base class that your module depends upon
    using the qmlRegisterRevision() function:

    \code
    template<typename T, int metaObjectRevision>
    int qmlRegisterRevision(const char *uri, int versionMajor, int versionMinor)

    template<typename T, int metaObjectRevision>
    int qmlRegisterUncreatableType(const char *uri, int versionMajor, int versionMinor, const char *qmlName, const QString& reason)
    \endcode

    For example, if \c BaseObject is changed and now has a revision 1, you can specify that
    your module uses the new revision:

    \code
    qmlRegisterRevision<BaseObject,1>("MyModule", 1, 1);
    \endcode

    This is useful when deriving from base classes not declared as part of your
    module, e.g. when extending classes from the QtQuick library.

    The revision feature of QML allows for behavioral changes without breaking
    existing applications. Consequently, QML module authors should always
    remember to document what changed between minor versions, and QML module
    users should check that their application still runs correctly before
    deploying an updated import statement.

\target qml-c++-coercion
\section1 Inheritance and Coercion

    QML supports C++ inheritance hierarchies and can freely coerce between
    known, valid object types. This enables the creation of common base classes
    that allow the assignment of specialized classes to object or list
    properties.

    \snippet examples/qml/cppextensions/referenceexamples/coercion/example.qml 0

    The QML snippet shown above assigns a \c Boy object to the \c
    BirthdayParty's \c host property, and assigns three other objects to the \c
    guests property. Both the \c host and the \c guests properties binds to the
    \c Person type, but the assignment is valid as both the \c Boy and \c Girl
    objects inherit from \c Person.

    To assign to a property, the property's type must have been
    \l{Creating QML Object Types from C++}{registered} to the \l{QQmlEngine}{declarative
    runtime}. If a type that acts purely as a base class that cannot be
    instantiated from QML needs to be registered as well. The
    \l qmlRegisterType() is useful for this occasion.

    \code
        template<typename T>
        int qmlRegisterType()
    \endcode

    This function registers the C++ type \a T with the QML system. The
    parameterless call to the template function qmlRegisterType() does not
    define a mapping between the C++ class and a QML element name, so the type
    is not instantiable from QML, but it is available for type coercion.

    \snippet examples/qml/cppextensions/referenceexamples/coercion/main.cpp 0
    \snippet examples/qml/cppextensions/referenceexamples/coercion/main.cpp register boy girl
    The \c Person class is registered withouth the parameters. Both the
    \c Boy and \c Girl class derive from the \c Person class.

    Type \a T must inherit QObject, but there are no restrictions on whether it
    is concrete or the signature of its constructor.

    QML will automatically coerce C++ types when assigning to either an object
    property, or to a list property. Only if coercion fails does an assignment
    error occur.

    The \l{Extending QML - Inheritance and Coercion Example}{Inheritance and Coercion Example}
    shows the complete code used to create the \c Boy and \c Girl types.

\target qml-c++-extension
\section1 Extension Objects

    \snippet examples/qml/cppextensions/referenceexamples/extended/example.qml 0

    The \c leftMargin property is a new property to an existing C++ type,
    \l QLineEdit, without modifying its source code.

    When integrating existing classes and technology into QML, APIs will
    often need tweaking to fit better into the declarative environment.
    Although the best results are usually obtained by modifying the original
    classes directly, if this is either not possible or is complicated by some
    other concerns, extension objects allow limited extension possibilities
    without direct modifications.

    \e{Extension objects} add additional properties to an existing type.
    Extension objects can only add properties, not signals or methods. An
    extended type definition allows the programmer to supply an additional type,
    known as the \e{extension type}, when registering the class. The
    properties are transparently merged with the original target class when used
    from within QML.

    The \l qmlRegisterExtendedType() is for registering extended types. Note
    that it has two forms.
    \code
    template<typename T, typename ExtendedT>
    int qmlRegisterExtendedType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)

    template<typename T, typename ExtendedT>
    int qmlRegisterExtendedType()
    \endcode
    functions should be used instead of the regular \c qmlRegisterType() variations.
    The arguments are identical to the corresponding non-extension registration functions,
    except for the ExtendedT parameter which is the type
    of the extension object.

    An extension class is a regular QObject, with a constructor that takes a
    QObject pointer. However, the extension class creation is delayed until the
    first extended property is accessed. The extension class is created and the
    target object is passed in as the parent. When the property on the original
    is accessed, the corresponding property on the extension object is used
    instead.

    The \l{Extending QML - Extension Objects}{Extension Objects} example
    demonstrates a usage of extension objects.




*/
