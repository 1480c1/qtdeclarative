#ifndef QV4UNWINDHELPER_PDW2_H
#define QV4UNWINDHELPER_PDW2_H

#include <qv4unwindhelper.h>
#include <qv4functionobject.h>
#include <wtf/Platform.h>

#include <QtCore/QHash>

extern "C" void __register_frame(void*);
extern "C" void __deregister_frame(void*);

namespace QQmlJS {
namespace VM {

namespace {
#if CPU(X86_64)
// Generated by fdegen
static const unsigned char cie_fde_data[] = {
    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1, 0x0, 0x8, 0x78, 0x10, 0xc, 0x7, 0x8,
    0x90, 0x1, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0,
    0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x41, 0x13, 0x7e, 0x86,
    0x2, 0x43, 0xd, 0x6, 0x8c, 0x3, 0x8e, 0x4,
    0x0, 0x0, 0x0, 0x0
};
static const int fde_offset = 20;
static const int initial_location_offset = 28;
static const int address_range_offset = 36;
#elif CPU(X86) && OS(LINUX)
static const unsigned char cie_fde_data[] = {
    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1, 0x0, 0x4, 0x7c, 0x8, 0xc, 0x4, 0x4,
    0x88, 0x1, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0,
    0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x41, 0x13, 0x7e, 0x85,
    0x2, 0x43, 0xd, 0x5, 0x86, 0x3, 0x87, 0x4,
    0x0, 0x0, 0x0, 0x0,
};
static const int fde_offset = 20;
static const int initial_location_offset = 28;
static const int address_range_offset = 32;
#endif
} // anonymous namespace

void UnwindHelper::registerFunctions(QVector<Function *> functions)
{
    foreach (Function *f, functions) registerFunction(f);
}

void UnwindHelper::deregisterFunction(Function *function)
{
    if (function->unwindInfo.isEmpty())
        return;
    __deregister_frame(function->unwindInfo.data() + fde_offset);
}

void UnwindHelper::deregisterFunctions(QVector<Function *> functions)
{
    foreach (Function *f, functions) deregisterFunction(f);
}

namespace {
void writeIntPtrValue(unsigned char *addr, intptr_t val)
{
    addr[0] = (val >>  0) & 0xff;
    addr[1] = (val >>  8) & 0xff;
    addr[2] = (val >> 16) & 0xff;
    addr[3] = (val >> 24) & 0xff;
#if QT_POINTER_SIZE == 8
    addr[4] = (val >> 32) & 0xff;
    addr[5] = (val >> 40) & 0xff;
    addr[6] = (val >> 48) & 0xff;
    addr[7] = (val >> 56) & 0xff;
#endif
}
} // anonymous namespace

void UnwindHelper::registerFunction(Function *function)
{
    if (function->unwindInfo.isEmpty())
        return;
    __register_frame(function->unwindInfo.data() + fde_offset);
}

QByteArray UnwindHelper::createUnwindInfo(Function *f, size_t functionSize)
{
    QByteArray info;
    info.resize(sizeof(cie_fde_data));

    unsigned char *cie_and_fde = reinterpret_cast<unsigned char *>(info.data());
    memcpy(cie_and_fde, cie_fde_data, sizeof(cie_fde_data));

    intptr_t ptr = static_cast<char *>(f->codeRef.code().executableAddress()) - static_cast<char *>(0);
    writeIntPtrValue(cie_and_fde + initial_location_offset, ptr);

    writeIntPtrValue(cie_and_fde + address_range_offset, functionSize);

    return info;
}

} // VM namespace
} // QQmlJS namespace

#endif // QV4UNWINDHELPER_PDW2_H
